using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Reflection.Emit;
using System.Text;
using System.Text.RegularExpressions;

namespace EntityFrameworkCore.RawQueryBuilder
{
    /// <summary>
    /// A List of Parameters that are passed to EF methods
    /// </summary>
    public class ParameterInfos
    {
        #region members
        private object[] _efParameters = null;
        private List<ParameterInfo> _parms = new List<ParameterInfo>();
        Dictionary<string, ParameterInfo> _nameToParm = new Dictionary<string, ParameterInfo>(StringComparer.OrdinalIgnoreCase);
        Dictionary<ParameterInfo, string> _parmToName = new Dictionary<ParameterInfo, string>();
        #endregion

        #region ctors
        /// <summary>
        /// List of SQL parameters which are passed to EF
        /// </summary>
        public ParameterInfos() : base()
        {
        }
        #endregion

        #region Items
        /// <summary>
        /// Convert the current parameters into EF parameters, since EF will automagically set DbTypes, Sizes, etc, and map to our databases
        /// </summary>
        public virtual object[] Items
        {
            get
            {
                //if (_efParameters == null) // TODO: cache?
                {
                    _efParameters = new object[_parms.Count];
                    for (int i = 0; i < _parms.Count; i++)
                    {
                        _efParameters[i] = _parms[i].Value;
                        // Dapper: _efParameters.Add(parameter.Name, parameter.Value, parameter.DbType, parameter.ParameterDirection, parameter.Size);
                    }
                }
                return _efParameters;
            }
        }
        #endregion

        /// <summary>
        /// Add a parameter to this dynamic parameter list.
        /// </summary>
        public void Add(ParameterInfo parameter)
        {
            _parms.Add(parameter);
            _nameToParm[parameter.Name] = parameter;
            _parmToName[parameter] = parameter.Name;
        }

        /// <summary>
        /// Add a parameter to this dynamic parameter list (reusing existing parameter if possible)
        /// </summary>
        public string Add( object value, DbType? dbType = null, ParameterDirection? direction = null )
        {
            //TODO
            ParameterInfo existingParam = null; 
                //_parms.FirstOrDefault(p =>
                //    p.DbType == dbType 
                //    && p.ParameterDirection == direction 
                //    && direction == ParameterDirection.Input
                //    && ((p.Value == null && value == null) || (p.Value!=null && p.Value.Equals(value)))
                //    );

            if ( existingParam != null )
            {
                throw new NotImplementedException(); // check this.
                //return InterpolatedStatementParser.AutoGeneratedParameterFactory + existingParam.Name.Substring( InterpolatedStatementParser.AutoGeneratedParameterObjectPrefix.Length );
            }
            else
            {
                var parmCount = _parms.Count;
                var parmName = InterpolatedStatementParser.AutoGeneratedParameterNameFactory(parmCount.ToString());
                var parmObjectName = InterpolatedStatementParser.AutoGeneratedParameterObjectNameFn(parmCount.ToString());

                var parameter = new ParameterInfo( parmObjectName, value, dbType, direction );

                _parms.Add(parameter);
                _nameToParm[parameter.Name] = parameter;
                _parmToName[parameter] = parameter.Name;
                return parmName;
            }
        }
        
        /// <summary>
        /// Get parameter value
        /// </summary>
        public T Get<T>(string key) => (T)_nameToParm[key].Value;

        /// <summary>
        /// Determines is this object contains any elements.
        /// </summary>
        /// <returns></returns>
        public bool Any() => _parms.Any();

        /// <summary>
        /// Parameter Names
        /// </summary>
        public HashSet<string> ParameterNames => new HashSet<string>(_nameToParm.Keys);


        #region Add Existing Parameter
        /// <summary>
        /// Merges single parameter into this list. <br />
        /// Checks for name clashes, and will rename parameter if necessary. <br />
        /// If parameter is renamed the new name will be returned, else returns null.
        /// </summary>
        public string MergeParameter(ParameterInfo parameter)
        {
            //TODO
            ParameterInfo existingParam = null; 
                //_parms.FirstOrDefault(p =>
                //    p.DbType == parameter.DbType 
                //    && p.ParameterDirection == parameter.ParameterDirection 
                //    && parameter.ParameterDirection == ParameterDirection.Input
                //    && ((p.Value == null && parameter.Value == null) || (p.Value!=null && p.Value.Equals(parameter.Value)))
                //    );

            if ( existingParam != null )
            {
                return existingParam.Name;
            }

            string newParameterName = InterpolatedStatementParser.AutoGeneratedParameterObjectNameFn(ParameterNames.Count.ToString());

            // Create a copy, it's safer
            ParameterInfo newParameter = new ParameterInfo(
                name: newParameterName, 
                value: parameter.Value,
                dbType: parameter.DbType, 
                direction: parameter.ParameterDirection,
                size: parameter.Size, 
                precision: parameter.Precision,
                scale: parameter.Scale
            );
            newParameter.OutputCallback = parameter.OutputCallback;

            Add(newParameter);
            return newParameterName;
        }

        /// <summary>
        /// Merges multiple parameters into this list. <br />
        /// Checks for name clashes, and will rename parameters if necessary. <br />
        /// If some parameter is renamed the returned Sql statement will containg the original sql replaced with new names, else (if nothing changed) returns null. <br />
        /// </summary>
        public string MergeParameters(ParameterInfos parameters, string sql)
        {
            Dictionary<string, string> renamedParameters = new Dictionary<string, string>();
            foreach (var parameter in parameters._parms)
            {
                string newParameterName = MergeParameter(parameter);
                if (newParameterName != null)
                {
                    string oldName = InterpolatedStatementParser.AutoGeneratedParameterNameFactory(parameter.Name.Substring(InterpolatedStatementParser.AutoGeneratedParameterObjectNameFn("0").Length - 1));
                    string newName = InterpolatedStatementParser.AutoGeneratedParameterNameFactory(newParameterName.Substring(InterpolatedStatementParser.AutoGeneratedParameterObjectNameFn("0").Length - 1));
                    renamedParameters.Add(oldName, newName);
                }
            }
            if (renamedParameters.Any())
            {
                Regex matchParametersRegex = new Regex("(?:[a-zA-Z0-9~=<>*/%+&|^-]|\\s|\\b|^) (" + string.Join("|", renamedParameters.Select(p=>p.Key.Replace("{", "\\{").Replace("}", "\\}"))) + ") (?:[a-zA-Z0-9~=<>*/%+&|^-]|\\s|\\b|$)",
                    RegexOptions.CultureInvariant | RegexOptions.IgnorePatternWhitespace | RegexOptions.Compiled);
                string newSql = matchParametersRegex.Replace(sql, match => {
                    Group group = match.Groups[match.Groups.Count-1]; // last match is the inner parameter
                    string replace = renamedParameters[group.Value];
                    return String.Format("{0}{1}{2}", match.Value.Substring(0, group.Index - match.Index), replace, match.Value.Substring(group.Index - match.Index + group.Length));
                });
                return newSql;
            }
            return null;
        }

        #endregion


    }


}
